<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SycloverSecurity | Focus on Cyber Security</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-07T15:05:43.974Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>将注入进行到底:利用Mono注入C#游戏脚本</title>
    <link href="http://yoursite.com/2019/01/07/Injecting-code-into-C-Sharp-game-scripts-via-Mono/"/>
    <id>http://yoursite.com/2019/01/07/Injecting-code-into-C-Sharp-game-scripts-via-Mono/</id>
    <published>2019-01-07T15:03:54.000Z</published>
    <updated>2019-01-07T15:05:43.974Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Author: 01dTan9@SycloverSecurity</strong><br><br><br></p><h3><span id="目录">目录</span></h3><!-- toc --><ul><li><a href="#1-游戏脚本是什么">1. 游戏脚本<em>是什么</em>？</a></li><li><a href="#2-为什么要注入游戏脚本">2. <em>为什么要注入</em>游戏脚本？</a><ul><li><a href="#21传统注入方式">2.1传统注入方式</a></li><li><a href="#22从硬编码注入到脚本注入">2.2从硬编码注入到脚本注入</a></li></ul></li><li><a href="#3-mono-与-unity-下的c游戏脚本">3. Mono 与 Unity 下的C#游戏脚本</a><ul><li><a href="#31-unity3d">3.1 Unity3D</a></li><li><a href="#32-mono">3.2 Mono</a></li><li><a href="#33-mono和unity3d">3.3 Mono和Unity3D</a></li></ul></li><li><a href="#4如何利用-mono平台实现-游戏脚本注入">4.<em>如何利用</em> Mono平台<em>实现</em> 游戏脚本注入？</a><ul><li><a href="#41-c库文件">4.1 C#库文件</a></li><li><a href="#42-动态链接库">4.2 动态链接库</a></li><li><a href="#43-主程序">4.3 主程序</a></li></ul></li><li><a href="#5-脚本注入攻防思路">5. 脚本注入攻防思路</a><ul><li><a href="#51-如何对抗脚本注入anti-cheat">5.1 如何对抗脚本注入（Anti-Cheat）？</a></li><li><a href="#52-如何绕过防注入by-pass">5.2 如何绕过防注入（By Pass）？</a></li></ul></li><li><a href="#6总结">6.总结</a></li></ul><!-- tocstop --><h3><span id="1-游戏脚本是什么">1. 游戏脚本<em>是什么</em>？</span></h3><p><strong>脚本语言</strong>（英语：Scripting language）是为了缩短传统的“编写、编译、链接、运行”（edit-compile-link-run）过程而创建的计算机编程语言。早期的脚本语言经常被称为批处理语言或工作控制语言。一个脚本通常是解释运行而非编译。<br><strong>游戏脚本</strong>由于脚本语言的开发成本低，许多游戏引擎不约而同地使用了脚本语言作为主要编程语言，比如大名鼎鼎的《魔兽世界》，就是使用的Lua进行开发的。本文所描述的游戏脚本是Unity（游戏引擎）中使用的主要编程语言——C#，并且Unity提供C＃中的主要脚本API ，其脚本具有简单、易学、易用的特性，目的就是希望能让开发人员快速完成游戏开发。</p><h3><span id="2-为什么要注入游戏脚本">2. <em>为什么要注入</em>游戏脚本？</span></h3><h4><span id="21传统注入方式">2.1传统注入方式</span></h4><p>对于传统的第三方游戏插件开发而言，由于没有游戏厂商提供的官方接口，只能通过非常规的方式将插件的功能安装在游戏中。</p><p>通常来说，这些安装的方式与病毒的行为十分类似，更偏向于系统底层，比如利用Windows API修改目标进程中的数据，或者创建远程线程让目标进程执行汇编代码或加载第三方库（如DLL），更有甚者，直接在Windows内核中劫持目标进程网络通讯，或进行APC注入。</p><p>目前传统的应用层注入方式主要有以下几种：</p><p>静态注入类：    </p><ul><li><strong>导入表注入</strong>   </li><li><strong>注册表注入</strong>  </li><li><strong>DLL劫持注入</strong></li></ul><p>动态注入类：         </p><ul><li><strong>钩子注入</strong>   </li><li><strong>APC注入</strong>    </li><li><strong>远程线程注入</strong>    </li><li><strong>输入法注入</strong>       </li><li><strong>LSP注入</strong></li></ul><p>使用上述方法安装的插件，其功能实现大部分要靠硬编码、钩子、内存修改来实现。这样一来，需要耗费大量的时间分析游戏的汇编代码与通过内存中的数据来构建结构体与游戏对象。</p><h4><span id="22从硬编码注入到脚本注入">2.2从硬编码注入到脚本注入</span></h4><p>假如我们可以让游戏脚本在游戏中执行，通过脚本直接使用游戏引擎封装好的函数与对象，不就可以事半功倍了吗？</p><h3><span id="3-mono-与-unity-下的c游戏脚本">3. Mono 与 Unity 下的C#游戏脚本</span></h3><h4><span id="31-unity3d">3.1 Unity3D</span></h4><p><strong>Unity3D</strong>是由Unity Technol<br>ogies开发的一个让玩家轻松创建诸如三维视频游戏、建筑可视化、实时三维动画等类型互动内容的多平台的综合型游戏开发工具，是一个全面整合的专业游戏引擎。Unity使用户能够以2D和3D方式创建游戏，并且引擎提供<strong>C＃</strong>中的主要脚本API ，用于插件形式的Unity编辑器，游戏本身以及拖放功能。在 <strong>C＃</strong>作为引擎使用的主要编程语言之前，Unity支持 <strong>Boo</strong> 和 <strong>JavaScript</strong> 版本的 <strong>UnityScript</strong>。</p><h4><span id="32-mono">3.2 Mono</span></h4><p><strong>Mono</strong>是一个免费的开源项目。由微软的子公司Xamarin（前身为Novell，最初由Ximian）和.NET基金会领导。旨在构建符合ECMA（欧洲计算机制造商协会）标准的<strong>.NET Framework</strong>兼容工具集。包括 <strong>C＃</strong>编译器和带有实时<strong>（JIT）</strong>编译的公共语言运行时。</p><h4><span id="33-mono和unity3d">3.3 Mono和Unity3D</span></h4><p>简单来说，Mono是Unity3D的一个运行时，负责C/C++和C#/CIL的交互。</p><p>举个例子，随便打开一个Unity游戏的根目录，你会发现一个名为<strong>UnityPlayer.dll</strong>的动态链接库，这个动态链接库封装是Unity的底层C++代码。</p><p>在 <code>游戏根目录\Mono\EmbedRuntime\</code> （某些低版本Unity游戏目录为<code>游戏根目录\Mono\</code>,笔者的为 2018.2.0 Beta）下有一个名为<strong>mono.dll</strong>的动态链接库，这个便是负责C/C++和C#/CIL的交互的模块，网上有开源版本，但许多游戏公司为了防止游戏被恶意修改，通常都重新编译mono.dll，在其中加入加密游戏数据与检测恶意行为的代码。</p><p>在<code>游戏根目录\游戏名_Data\Managed\</code>中名为<strong>Assembly-CSharp.dll</strong>的文件便是C#脚本代码。</p><p>三者的关系如下：</p><p><img src="./1537771735299.png" alt="Alt text"></p><h3><span id="4如何利用-mono平台实现-游戏脚本注入">4.<em>如何利用</em> Mono平台<em>实现</em> 游戏脚本注入？</span></h3><blockquote><p>利用Mono平台实现游戏脚本注入的主要方法有两种，一种是静态修改，直接Patch<strong>Assembly-CSharp.dll</strong>的代码。<br>本文测试环境是在Windows下，主要是阐述思路，Android平台的注入同理。<br>另一种是调用mono.dll的API，动态加载C#代码（移动端同理），本文主要讨论后者。</p><p>代码实现主要由三部分组成：<br>C#库文件（负责实现第三方功能）<br>动态链接库（用于在目标程序加载脚本）<br>主程序（负责注入DLL到目标程序）</p></blockquote><h4><span id="41-c库文件">4.1 C#库文件</span></h4><p>负责实现第三方功能，代码需要因游戏而定，主要是通过获取或修改Unity原生组件（Transform、physics等）的数据实现第三方功能，也可以直接使用开发者定义的函数，但这种方法需要获取游戏源代码，需要解密脚本文件，在此不再赘述。</p><h4><span id="42-动态链接库">4.2 动态链接库</span></h4><p>在目标进程中载入C#脚本需要以下API，具体参数查阅mono官方文档，上面都有详细解释。</p><p>通过文件名加载C#脚本文件镜像。</p><pre><code>mono_image_open_from_data</code></pre><p>从文件镜像中读取并将C#代码编译为IL代码，至此，C#代码被即时编译完毕。</p><pre><code>mono_assembly_load_from_full</code></pre><p>获取IL代码的镜像。</p><pre><code>mono_assembly_get_image</code></pre><p>通过类名获取类句柄，供mono_class_get_method_from_name调用。</p><pre><code>mono_class_from_name</code></pre><p>通过类句柄和函数名获取函数地址，供mono_runtime_invoke调用。</p><pre><code>mono_class_get_method_from_name</code></pre><p>通过函数地址运行IL代码，代码开始运行。</p><pre><code>mono_runtime_invoke</code></pre><p>在调用mono的API之前，我们需要获取API的函数地址，基本方法如下：   </p><p>首先获取mono.dll的模块句柄</p><pre><code>HMODULE hMono = GetModuleHandle(L&quot;mono.dll&quot;);</code></pre><p>再获取API地址</p><pre><code>typedef void* (__cdecl *MONO_IMAGE_OPEN_FROM_DATA)(char *ImageName);MONO_IMAGE_OPEN_FROM_DATA mono_image_open_from_data;mono_image_open_from_data = (MONO_IMAGE_OPEN_FROM_DATA)GetProcAddress(hMono, &quot;mono_image_open_from_data&quot;);</code></pre><p>用这种方法获取所有需要调用的API</p><p>加载C#脚本代码</p><pre><code>#define ClassName L&quot;ClassName&quot;#define MethodName L&quot;MethodName&quot;#define name_space L&quot;name_space&quot;intptr_t raw_image = ImageOpenFromDataFull(file_data);intptr_t assembly = AssemblyLoadFromFull(raw_image);intptr_t image = AssemblyGetImage(assembly);intptr_t class_id = GetClassFromName(image, name_space, ClassName);intptr_t method = GetMethodFromName(class_id, MethodName);RuntimeInvokeMethod(method);    </code></pre><p>还可以在DLL中实现C#热更新，方便调试。</p><h4><span id="43-主程序">4.3 主程序</span></h4><p>主程序负责将动态链接库注入到目标程序。</p><p>通过上文提到的远程线程注入方法</p><p>使用 <code>CreateRemoteThread</code> 远程调用 <code>LoadLibrary</code> 即可。</p><h3><span id="5-脚本注入攻防思路">5. 脚本注入攻防思路</span></h3><h4><span id="51-如何对抗脚本注入anti-cheat">5.1 如何对抗脚本注入（Anti-Cheat）？</span></h4><p>对抗脚本注入，有以下几种、主要思路是在mono.dll上做手脚。</p><ul><li><p>当前流行的方法通过修改mono源码，加密Assembly-CSharp.dll，并在mono_image_open_from_data里加入解密脚本的函数，这样既可以防止脚本被静态Patch，又可以防止动态注入。</p></li><li><p>Android平台下的进程保护</p></li><li><p>Windows平台下的进程保护（R0、R3）</p></li></ul><p>另外一种是在其他mono函数加入检测代码。笔者所遇到便是在mono_class_from_name加入检测代码，非原生脚本的加载都会导致函数调用崩溃。</p><h4><span id="52-如何绕过防注入by-pass">5.2 如何绕过防注入（By Pass）？</span></h4><ul><li><p>利用没有被修改的函数加载代码，如mono_assembly_foreach枚举IL代码镜像，绕过mono_class_from_name的检测。</p></li><li><p>重写mono_class_from_name函数。</p></li><li><p>加载另一个纯净的mono.dll，使用纯净模块里面的函数来加载代码。</p></li></ul><h3><span id="6总结">6.总结</span></h3><p>利用mono平台注入C#代码大大提高了开发效率，如果是单纯用原生Unity组件开发出来的代码基本上适用于所有用Unity引擎开发的游戏。</p><p>未来Unity可能会放弃mono平台，转用LICPP平台，但是短时间内是不会放弃mono这个成熟的平台的，所以，本方法在未来一段时间内都有利用价值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Author: 01dTan9@SycloverSecurity&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span id=&quot;目录&quot;&gt;目录&lt;/span&gt;&lt;/h3&gt;&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-游戏脚本是
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剖析Hash传递攻击的本质、缓解方式及部分绕过手段</title>
    <link href="http://yoursite.com/2018/10/02/What-is-Pass-the-Hash-and-the-Limitations-of-mitigation-methods/"/>
    <id>http://yoursite.com/2018/10/02/What-is-Pass-the-Hash-and-the-Limitations-of-mitigation-methods/</id>
    <published>2018-10-02T12:57:15.000Z</published>
    <updated>2018-10-02T13:09:55.499Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Author: Exist@SycloverSecurity</strong><br><strong>2018/09/04</strong><br><br><br></p><!-- toc --><ul><li><a href="#lm-hash-ntlm-hash-net-ntlm-hash的区别与联系">LM Hash、NTLM Hash、Net-NTLM Hash的区别与联系</a><ul><li><a href="#lm-hash">LM Hash</a></li><li><a href="#ntlm-hash">NTLM Hash</a></li><li><a href="#net-ntlm-hash">Net-NTLM Hash</a></li><li><a href="#联系">联系</a></li></ul></li><li><a href="#ntlm认证">NTLM认证</a><ul><li><a href="#工作组环境">工作组环境</a></li><li><a href="#域环境">域环境</a></li></ul></li><li><a href="#网络登录与非网络登录">网络登录与非网络登录</a><ul><li><a href="#网络登陆">网络登陆</a></li><li><a href="#非网络登陆">非网络登陆</a></li><li><a href="#网络登录与ntlm认证">网络登录与NTLM认证</a></li></ul></li><li><a href="#pth攻击原理">PtH攻击原理</a></li><li><a href="#pth操作演示">PtH操作演示</a></li><li><a href="#缓解手段及其局限性或可能的绕过方式">缓解手段及其局限性或可能的绕过方式</a><ul><li><a href="#kb2871997">kb2871997</a><ul><li><a href="#删除lsass的明文凭证">删除lsass的明文凭证</a><ul><li><a href="#局限性">局限性</a></li></ul></li><li><a href="#能够禁止用户网络登录">能够禁止用户网络登录</a><ul><li><a href="#局限性-1">局限性</a></li></ul></li><li><a href="#添加受限管理员模式">添加“受限管理员模式”</a><ul><li><a href="#局限性-2">局限性</a></li></ul></li><li><a href="#protected-users">Protected Users</a><ul><li><a href="#局限性-3">局限性</a></li></ul></li></ul></li><li><a href="#additional-lsa-protection">Additional LSA Protection</a><ul><li><a href="#绕过方式">绕过方式</a></li></ul></li><li><a href="#microsoft本地管理员密码解决方案laps">Microsoft本地管理员密码解决方案（LAPS）</a><ul><li><a href="#局限性-4">局限性</a></li></ul></li><li><a href="#credentials-guard">Credentials Guard</a><ul><li><a href="#绕过方式-1">绕过方式</a><ul><li><a href="#memssp">memssp</a></li><li><a href="#netntlm-downgrade-attack">NetNTLM Downgrade Attack</a></li></ul></li></ul></li></ul></li><li><a href="#总结">总结</a></li><li><a href="#thanks">Thanks</a></li></ul><!-- tocstop --><h2><span id="lm-hash-ntlm-hash-net-ntlm-hash的区别与联系">LM Hash、NTLM Hash、Net-NTLM Hash的区别与联系</span></h2><h3><span id="lm-hash">LM Hash</span></h3><p>LM Hash是一种较古老的Hash，在LAN Manager协议中使用，非常容易通过暴力破解获取明文凭据。Vista以前的Windows OS使用它，Vista之后的版本默认禁用了LM协议，但某些情况下还是可以使用。</p><h3><span id="ntlm-hash">NTLM Hash</span></h3><p>Vista以上现代操作系统使用的Hash。通常意义上的NTLM Hash指存储在SAM数据库及NTDS数据库中对密码进行摘要计算后的结果，这类Hash可以直接用于PtH，并且通常存在于<a href="https://en.wikipedia.org/wiki/Local_Security_Authority_Subsystem_Service" target="_blank" rel="noopener">lsass</a>进程中，便于<a href="https://docs.microsoft.com/zh-cn/windows/desktop/SecGloss/s-gly#_security_security_support_provider_gly" target="_blank" rel="noopener">SSP</a>使用</p><h3><span id="net-ntlm-hash">Net-NTLM Hash</span></h3><p>Net-NTLM Hash用于网络身份认证（例如ntlm认证中），目前分为两个版本：</p><ul><li>Net-NTLMv1</li><li>Net-NTLMv2</li></ul><p>通常我们使用Responder等工具获取到的就是NetNTLM，这类hash并不能直接用来PtH，但有可能通过暴力破解来获取明文密码</p><h3><span id="联系">联系</span></h3><p>Net-NTLM出现在NTLM认证过程中，其计算过程依赖NTLM Hash<br><br></p><blockquote><p>参考资料：<br><a href="https://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4" target="_blank" rel="noopener">https://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4</a></p></blockquote><hr><h2><span id="ntlm认证">NTLM认证</span></h2><p>本文提到的NTLM认证特指Microsoft NTLM Protocol。</p><h3><span id="工作组环境">工作组环境</span></h3><p><a href="https://docs.microsoft.com/en-us/windows/desktop/secauthn/microsoft-ntlm" target="_blank" rel="noopener">NTLM认证</a>是一种在网络上进行认证的安全协议，其主要过程粗略地分为三步：</p><ol><li>客户端发起认证请求</li><li>服务端收到认证请求，向客户端发送随机数（chanlleng/挑战）</li><li>客户端使用NTLM Hash打乱该随机数，生成Net-NTLM Hash，发送回服务端</li></ol><p><img src="./1535997407487.png" alt="Alt text"></p><h3><span id="域环境">域环境</span></h3><p>上面的过程发生在工作组环境中，在域环境中使用NTLM Pass-Through认证，核心过程与工作组没有太大区别：<br><img src="./1536303404744.png" alt="Alt text"><br><br><br>主要区别在于Server会将认证信息使用netlogon协议发送给域控制器，由域控制器完成检验并返回认证结果</p><blockquote><p>参考资料：<br><a href="http://davenport.sourceforge.net/ntlm.html" target="_blank" rel="noopener">http://davenport.sourceforge.net/ntlm.html</a></p></blockquote><p><br></p><hr><h2><span id="网络登录与非网络登录">网络登录与非网络登录</span></h2><h3><span id="网络登陆">网络登陆</span></h3><p>在网络登录过程中不使用凭证输入对话框来收集数据，而会使用到预先生成的凭据。</p><h3><span id="非网络登陆">非网络登陆</span></h3><p>分为网络明文登陆和交互式登陆等。这些登录类型在认证期间将用户明文密码发送到服务器。 服务器可以在LSASS中缓存这个密码或其处理后的值，并使用它来验证其他资源。</p><h3><span id="网络登录与ntlm认证">网络登录与NTLM认证</span></h3><p>NTLM认证出现在网络登录中，而远程服务器不缓存用户凭据，这也与ntlm认证的特性相吻合。 Double-Hop的问题也与网络/非网络登录的性质有关。</p><hr><h2><span id="pth攻击原理">PtH攻击原理</span></h2><p>注意：本文所指均为狭义上的Pass-the-Hash，即一种在<strong>NTLM认证中</strong>使用<strong>NTLM Hash</strong>进行认证的手段<br><br><br><img src="./1535992842471.png" alt="Alt text"><br><br><br>在上面的三步过程中，我们发现并没有使用到用户提供的明文密码，而是使用NTLM Hash来计算NetNTLM Hash。Hash传递攻击就发生在NTLM认证的第三步，我们能使用获取到的<strong>NTLM Hash</strong>来完成一次完整的认证。</p><h2><span id="pth操作演示">PtH操作演示</span></h2><p>靶机ip：<br><img src="./1536303053406.png" alt="Alt text"><br><br><br><br>攻击机ip：<br><img src="./1536303076415.png" alt="Alt text"><br><br><br><br>以mimikatz为例，在攻击机上以管理员身份运行mimikatz：<br><img src="./1536303100010.png" alt="Alt text"><br><br><br><br>在攻击之前我们需要知道目标账户名以及hash值，这里我们假设获取到了ntlm hash：<br><img src="./1536303130177.png" alt="Alt text"><br><br><br><br>我们使用mimikatz来pth：<br><img src="./1535556149084.png" alt="Alt text"><br><br><br><br>这里需要domain，user，ntlm以及打开的程序四个参数。默认情况下打开cmd。<br>我们知道，pth只是一种无明文认证的手段，我们还需要针对具体的服务进行攻击，这里以smb服务为例。通常我们访问一个unc路径时，不考虑double-hop的情况下，如果没有指定windows会自动用当前用户的凭据进行ntlm认证，例如命令<code>dir \\Target\aaa</code>。由于windows某些ssp会在lsass中缓存hash值，并使用它们来ntlm认证，那么理论上我们如果在lsass中添加包含目标账户的hash的合法数据结构，就可以在使用类似dir这些命令时用目标账户进行认证，这也是mimikatz中pth功能的原理。<br>上一步里面我们已经用mimikatz修改了内存中的hash值，那么我们就能利用弹出的cmd来测试一下是否能网络登录目标系统，访问c\$共享。<br>这里使用的exist用户是非内置管理员用户，尽管c$共享允许管理员组成员访问，但由于uac对网络登录的限制，导致直接访问会被Access Died：<br><img src="./1536303194166.png" alt="Alt text"><br><br><br><br>出于演示的需要，我们把靶机上的UAC级别设置为<code>从不通知</code>并重启,再次pth：<br><img src="./1536303213838.png" alt="Alt text"></p><p><br><br><br>能成功访问c\$共享。</p><hr><h2><span id="缓解手段及其局限性或可能的绕过方式">缓解手段及其局限性或可能的绕过方式</span></h2><blockquote><p>试图缓解PtH的危害可以从两个方面入手（当然不仅仅是这两方面）：</p><ol><li>禁止NTLM认证</li><li>防止NTLM Hash被获取到</li></ol><p>第一种方式当然是一劳永逸地阻止了PtH，但是NTLM认证已经被微软使用了很长时间，完全禁止可能会破坏已部署的一些环境，在实际应用中阻力较大。<br>由于NTLM认证的天然缺陷，微软似乎很难改变其行为，因此更多地把防御放在了阻止Hash被获取到这种思路。下面我们来介绍微软发布的一些补丁以及它们可能的绕过方式。</p></blockquote><h3><span id="kb2871997">kb2871997</span></h3><p>kb2871997在缓解PtH上做出了不少努力，其为windows增加的特性值得深入研究。它在win server 2012 R2及以上版本已默认集成。<br>根据<a href="https://blogs.technet.microsoft.com/askpfeplat/2016/04/18/the-importance-of-kb2871997-and-kb2928120-for-credential-protection/" target="_blank" rel="noopener">微软公告</a>，安装kb2871997后会有这么些行为：</p><h4><span id="删除lsass的明文凭证">删除lsass的明文凭证</span></h4><p>我们前面提到过，lsass进程会缓存用户凭据，有明文有Hash，这取决于使用的ssp类型以及补丁情况。<br><img src="./1536303250157.png" alt="Alt text"><br><br><br><br>上图中msv、tspkg、wdigest、kerberos这几个ssp都获取到了凭据，它们分别用于Terminal Server认证（RDSH），ntlm认证，摘要认证以及kerberos认证。我们能看到只有msv没有明文密码。从前文中对ntlm认证过程的描述，我们可以发现除了第一步客户端要求用户输入明文密码，之后的认证过程再也没有出现过明文密码。这也就是说，ssp只需要计算ntlm hash并放在内存中就行了。<br>我们看到摘要认证wdigest在windows 2008 中缓存了明文密码。摘要认证类似于ntlm认证，也使用了挑战-响应机制，但它与ntlm认证较大的区别在于客户端计算响应时，需要使用到<strong>明文密码</strong>，为了实现SSO，需要将明文密码放在内存中方便进行计算，因此客户端一方的ssp理论上必须在内存中缓存明文密码，这也是为什么我们能抓到明文密码的原因；与之相比，NTLM SSP使用的单向函数如NTOWFv2只需要计算一次并放置在内存中，之后计算响应只需要这个hash值即可。</p><p>kb2871997会删除除了wdigest ssp以外其他ssp的明文凭据，但对于wdigest ssp只能选择禁用。用户可以选择将<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest\UseLogonCredential</code>更改为0来禁用。<br><img src="./1536303275456.png" alt="Alt text"><br><br><br><br>安装kb2871997之后我们使用mimikatz抓取内存中的密码：<br><img src="./1536303309881.png" alt="Alt text"><br><br><br><br>wdigest ssp默认仍然在内存中存储明文密码，更改注册表后注销，重新登录，再次抓取：<br><img src="./1536303353652.png" alt="Alt text"><br><br><br><br>wdigest已经抓不到明文密码以及密码hash。<br><br><br></p><h5><span id="局限性">局限性</span></h5><p>这仅仅是增大了从内存中获取ntlm hash的难度，但并不能阻止从注册表等其他地方获取。<br><br></p><h4><span id="能够禁止用户网络登录">能够禁止用户网络登录</span></h4><p>下图中，工作组环境可以在<code>本地安全策略-&gt;用户权限分配-&gt;拒绝从网络访问这台计算机</code>配置是否允许用户或用户组网络登录：<br><img src="./1535558253586.png" alt="Alt text"><br><br><br>理论上UAC无法限制RID为500的用户网络登录，但打补丁并配置好禁止administrator(RID==500)网络登录，测试结果如下：<br><img src="./1535558275317.png" alt="Alt text"><br><br></p><h5><span id="局限性">局限性</span></h5><p>处理方式太过粗暴，可能会影响用户正常需求。<br><br><br></p><h4><span id="添加受限管理员模式">添加“受限管理员模式”</span></h4><p>受限管理员模式能阻止主机缓存内存中远程验证用户的凭据。<br><br><br>我们来做两个测试</p><ul><li>测试一： RDP客户端使用微软自家的mstsc，服务端未打kb2871997，不加任何参数启动：<br><img src="./1536046771895.png" alt="Alt text"><br><br><br><br>启动连接，客户端要求我们输入用户名和密码：<br><img src="./1536046815413.png" alt="Alt text"><br><br><br><br>登录成功后，使用mimikatz获取内存中的密码：<br><img src="./1536047730544.png" alt="Alt text"><br><br><br>我们能够获取到明文密码，ntlmssp的NTLM Hash也能获取到，这里就不再截图了。<br><br></li><li>测试二：客户端使用<code>mstsc /restrictedadmin</code>，也即受限管理员模式启动，服务端支持受限管理员模式：<br><img src="./1536048324409.png" alt="Alt text"><br><br><br>我们发现mstsc提示将使用我们到windows登录凭据进行连接。<br>如果客户端和服务端有相同用户名和密码的账户，可以直接连接成功，没有弹出要求输入凭据的对话框。连接成功后，使用mimikatz获取内存中的密码：<br><img src="./1536048807424.png" alt="Alt text"><br><br><br>我们发现远程桌面会话没有缓存用户凭据，这其实就是受限管理员模式的特性。<br><br><br><br>下面我们来聊聊为什么会出现这种情况：</li></ul><ol><li>远程桌面默认无约束委派用户凭据，以达到完全在远程服务器上代表用户的目的。当我们连接到远程桌面服务器上，可以使用dir命令连接其他的smb服务器并使用我们的凭据认证，这是因为客户端进行远程桌面连接的时候会发送用户的明文密码，这个密码可以用于计算NTLM Hash并缓存在远程桌面服务器上。</li><li>受限管理员模式下，远程桌面客户端会首先使用客户端机器上已缓存的NTLM Hash进行认证，不需要用户输入用户名和密码，也就不会把明文密码委派到目标；即便缓存的hash认证失败，用户必须输入明文密码，mstsc也不会直接发送明文密码，而是计算出所需的值后再发送。这种模式下，登录到远程桌面服务器上并使用dir命令向其他smb服务器认证时，将使用空用户(用户名<code>\</code> )登录，几乎都会登陆失败。</li></ol><p>从上面两种模式对比可以看出，客户端直接发送明文密码到服务端，可能会被mimikatz从内存中获取到；而受限管理员模式则能避免发送明文，服务端内存中也不会缓存用户凭据。</p><blockquote><p>参考<br><a href="https://blogs.technet.microsoft.com/kfalde/2013/08/14/restricted-admin-mode-for-rdp-in-windows-8-1-2012-r2/" target="_blank" rel="noopener">https://blogs.technet.microsoft.com/kfalde/2013/08/14/restricted-admin-mode-for-rdp-in-windows-8-1-2012-r2/</a></p></blockquote><p><br></p><h5><span id="局限性">局限性</span></h5><p>“受限管理员模式”的初衷是为了保护远程桌面服务端，即当服务端被攻陷时，使用受限管理员模式可以在一定程度上保护客户端用户的凭据不被mimikatz等工具获取到。因此，这个保护措施并不是直接针对PtH，效果也是有限的。<br>实际上受限管理员模式本身就会增加新的攻击路径，即可以以PtH的方式向远程桌面服务器发起认证。也就是说，在实际应用中，我们可以利用mimikatz的<code>sekurlsa::pth</code>来启动mstsc，使用受限管理员模式来无明文密码登录，当然也有些其他的RDP客户端可以实现利用密码Hash来认证，例如FreeRDP。</p><h4><span id="protected-users">Protected Users</span></h4><p>受保护用户是一个新的域全局安全组，对于该组的成员，Windows 8.1设备或Windows Server 2012 R2主机不会缓存受保护用户不支持的凭据。如果这些组的成员登录到运行早于Windows 8.1的Windows版本的设备，则该组的成员没有其他保护。</p><p>登录到Windows 8.1设备和Windows Server 2012 R2主机的受保护用户组的成员不能再使用：</p><ul><li>默认凭据委派（CredSSP） - 即使启用了“ 允许委派默认凭据”策略，也不会缓存纯文本凭据</li><li>Windows摘要 - 即使启用明文凭据也不会进行缓存</li><li>NTLM - NTOWF未缓存</li><li>Kerberos长期密钥 - Kerberos票证授予票证（TGT）在登录时获取，无法自动重新获取</li><li>离线登录 - 未创建缓存的登录验证程序</li></ul><p>如果域功能级别是Windows Server 2012 R2，则该组的成员不能再：</p><ul><li>使用NTLM身份验证进行身份验证</li><li>在Kerberos预身份验证中使用数据加密标准（DES）或RC4密码套件</li><li>通过使用无约束或约束委派来委派</li><li><p>更新用户票证（TGT）超过最初的4小时生命周期</p><p><img src="./1536303430715.png" alt="Alt text"><br><br><br><br>在域账户未加入Protected Users组时，我们使用mimikatz获取内存中的凭据：<br><img src="./1536303471082.png" alt="Alt text"><br><br><br><br>我们可以看到ntlmssp缓存了emanon账户的密码hash。我们将此用户加入Protected Users:<br><img src="./1536303522128.png" alt="Alt text"><br><img src="./1536303544312.png" alt="Alt text"><br><br><br><br>注销，重新登录，再次使用mimikatz抓取密码：<br><img src="./1536303567826.png" alt="Alt text"><br><br><br><br>emanon用户的ntlm hash已经无法获取到，但机器账户DM1$以及本地用户的hash仍然能获取到，这也说明Protected Users保护范围是有限的。<br><br><br>网上有些文章提到了Pass-the-Key（Overpass-the-hash），Protected Users对这种攻击方式也有一定缓解功能。PtK是在域中攻击kerberos认证的一种方式，据称可以在NTLM认证被禁止的情况下用来实现类似PtH的功能（毕竟是针对kerberos认证，其实与NTLM认证没什么关系）。关于这种攻击方式可以查看本节的参考，这里不再赘述。我们比较关心使用mimikatz来Pass-the-Key所需要的信息，其中必须有的是请求tgt所需的用户hash，这可以使用mimikatz中的<code>sekurlsa::ekeys</code>来获取：<br><img src="./1535996713513.png" alt="Alt text"><br><br><br>经测试，域功能级别为windows server 2012 R2（未测试低等级），将域用户加入Protected Users用户组后无法通过ekeys命令获取Hash。当然，机器账户还是能够获取到。</p></li></ul><h5><span id="局限性">局限性</span></h5><p>Protected Users是一个域安全组，仅能在域中保护用户，并且阻止抓取用户Hash并没有直面PtH这种攻击方式，域用户凭据仍可能通过注册表Cache、钓鱼攻击等方式获取到。</p><blockquote><p>参考资料：<br><a href="https://www.blackhat.com/docs/us-14/materials/us-14-Duckwall-Abusing-Microsoft-Kerberos-Sorry-You-Guys-Don&#39;t-Get-It-wp.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-14/materials/us-14-Duckwall-Abusing-Microsoft-Kerberos-Sorry-You-Guys-Don&#39;t-Get-It-wp.pdf</a></p></blockquote><h3><span id="additional-lsa-protection">Additional LSA Protection</span></h3><p>LSA（包括本地安全机构服务器服务（LSASS）进程）验证用户是否进行本地和远程登录，并实施本地安全策略。Windows 8.1操作系统为LSA提供额外保护，以防止未受保护的进程读取内存和代码注入。启用此功能后无法把debugger attach到进程上。在win8.1及2012 r2以上有效，启用的方法是<code>reg add HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa /v RunAsPPL /t REG_DWORD /d 1</code><br>之后重启。<br>重启之后，使用mimikatz抓取内存中的密码：<br><img src="./1536303605988.png" alt="Alt text"></p><p><br><br><br>使用<code>lsadump::lsa /inject</code>:<br><img src="./1536303619882.png" alt="Alt text"><br><br><br><br>同样无法获取到密码hash</p><p><br><br></p><h4><span id="绕过方式">绕过方式</span></h4><p>mimikatz能够通过加载其驱动程序来绕过LSA Protection。在实际使用中需要注意mimikatz同目录下需要有驱动程序mimidrv.sys<br>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">privilege::Debug</span><br><span class="line">!+</span><br><span class="line">!processprotect /process:lsass.exe /remove</span><br></pre></td></tr></table></figure></p><p><br><br><br>测试:<br><img src="./1535991415648.png" alt="Alt text"><br><img src="./1535991611789.png" alt="Alt text"><br><br><br></p><blockquote><p>参考资料：<br><a href="https://adsecurity.org/?page_id=1821" target="_blank" rel="noopener">https://adsecurity.org/?page_id=1821</a></p></blockquote><h3><span id="microsoft本地管理员密码解决方案laps">Microsoft本地管理员密码解决方案（LAPS）</span></h3><p>LAPS是用于管理计算机本地用户密码的一个客户端扩展（CSE），在域中依赖比较少，核心在于组策略支持。<br>LAPS一个重要功能是随机化所有域成员本地管理员密码，密码按照较强的密码策略生成，定期修改。这使得用相同凭据横向渗透变得很困难。</p><p>本地管理员密码明文存储在AD中，仅有管理员及获得管理员委派的账户能访问到。</p><h4><span id="局限性">局限性</span></h4><p>LAPS和仅仅增大了横向渗透的难度，并且配置上出错也可能导致前功尽弃。LAPS配置上可能出现的一个问题是向非授权用户授予“All Extended Rights”权限，这导致如果我们获取该账户，就能访问AD中的密码。</p><blockquote><p>参考资料：<br>  <a href="https://github.com/leoloobeek/LAPSToolkit" target="_blank" rel="noopener">https://github.com/leoloobeek/LAPSToolkit</a></p></blockquote><h3><span id="credentials-guard">Credentials Guard</span></h3><p>Credentials Guard是win10中引入的新功能，据称能保护NTLM密码哈希值，Kerberos票证授予票证和应用程序存储的凭据。该进程是唯一能使用明文凭据的进程，它的原理大概是这样：<br>当NTLM认证过程中需要用到例如ntlm hash这类凭证的时候（第三步），将Credentials Guard视为黑箱，由lsass等进程输入生成NetNTLM所需的信息（第二步收到的challenge等等），由CG处理并输出结果，而CG本身内存禁止读取，使得mimikatz这一类工具无从下手：<br><img src="./1533630135491.png" alt="Alt text"></p><blockquote><p>参考资料：<br><a href="https://www.blackhat.com/docs/us-15/materials/us-15-Moore-Defeating%20Pass-the-Hash-Separation-Of-Powers-wp.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/us-15/materials/us-15-Moore-Defeating%20Pass-the-Hash-Separation-Of-Powers-wp.pdf</a><br><br><br></p></blockquote><h4><span id="绕过方式">绕过方式</span></h4><p>对付Credentials Guard有一些曲线救国的方法：</p><h5><span id="memssp">memssp</span></h5><p>SSP的二进制形式是DLL，提供用来处理身份认证的接口（SSPI）。如果我们无法从内存中直接获取凭据，那么通过注册一个ssp来处理用户登录时输入的凭据也是一种办法。mimikatz直接在内存中加载自定义的ssp dll，能够在用户登录时获取到明文凭据。<br><br><br>演示：<br>mimikatz 内存注入ssp<br><img src="./1535557366764.png" alt="Alt text"><br><br><br><br>锁屏等待用户再次登录后，查看system32下的文件<br><img src="./1535557434501.png" alt="Alt text"></p><h5><span id="netntlm-downgrade-attack">NetNTLM Downgrade Attack</span></h5><p>NetNTLM有两个版本——v1和v2。v1相比v2更加脆弱，因此如果我们能将NetNTLMv2降级为v1，破解的效率会更高；如果能降级到NetLM，那么爆破成功率就变得极高。</p><p>在<a href="https://github.com/eladshamir/Internal-Monologue" target="_blank" rel="noopener">这篇文章</a>中提到了一种迂回获取凭据的方式，核心思想是修改注册表使Windows允许在网络认证中发送算法较弱的NetHash例如NetNTLMv1，而实际上我们可以直接与NTLM SSP交互而不必产生网络流量，并能获取到NetNTLMv1用于降低破解的难度。</p><p>Credentials Guard运行时，我们虽然不能直接从内存获取到NTLM Hash，但利用上面提到的思路获取NetNTLM Hash是有可能的。</p><p>Internal-Monologue.ps1使用演示：<br><img src="./1535557841066.png" alt="Alt text"></p><blockquote><p>参考资料：<br>  <a href="https://blog.nviso.be/2018/01/09/windows-credential-guard-mimikatz/" target="_blank" rel="noopener">https://blog.nviso.be/2018/01/09/windows-credential-guard-mimikatz/</a><br>  <a href="https://github.com/eladshamir/Internal-Monologue" target="_blank" rel="noopener">https://github.com/eladshamir/Internal-Monologue</a><br>  <a href="https://technet.microsoft.com/en-us/library/2006.08.securitywatch.aspx" target="_blank" rel="noopener">https://technet.microsoft.com/en-us/library/2006.08.securitywatch.aspx</a></p></blockquote><hr><h2><span id="总结">总结</span></h2><p>由于NTLM认证本身具有缺陷性，导致攻击者可以在不知道明文密码，只知道密码Hash的情况下完成认证。这个缺陷就目前来看无法修复，微软也只能建议使用更安全的kerberos协议来代替ntlm协议，而其发布的补丁也并没有触及PtH这种攻击思想的本质，仅仅是增大了攻击的难度或者粗暴地禁止NTLM认证，因此依然存在绕过的可能。</p><hr><h2><span id="thanks">Thanks</span></h2><p>我在学习及研究过程中受到<a href="http://unicorn.360.cn/" target="_blank" rel="noopener">@360无线电安全研究院</a>及@SycloverSecurity的大力支持与帮助，在此一并表示衷心的感谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Author: Exist@SycloverSecurity&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2018/09/04&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#lm-hash-nt
      
    
    </summary>
    
    
  </entry>
  
</feed>
